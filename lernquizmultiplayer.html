<script>
        /**
         * LERNQUIZ LIVE - ROBUST VERSION
         * Mit Auto-Reconnect und Keep-Alive
         */

        // --- KONFIGURATION ---
        const TIME_LIMIT_SEC = 30; 
        const MAX_POINTS = 1000;
        
        // STUN Server Config
        const PEER_CONFIG = {
            debug: 2, // Zeigt Fehler in der Konsole
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            }
        };

        // --- GLOBALS ---
        let peer = null;
        let conn = null; // Client
        let connections = {}; // Host
        let players = {}; 
        let quizData = null;
        let currentQuestionIndex = -1;
        let questionStartTime = 0;
        let questionActive = false;
        let answersCount = 0;
        let heartbeatInterval = null;

        // --- HELPER ---
        function getURLParameter(name) {
            const params = new URLSearchParams(window.location.search);
            return params.get(name);
        }

        // --- INIT ---
        window.addEventListener('DOMContentLoaded', () => {
            const moodleName = getURLParameter('moodleUser');
            if (moodleName) {
                const nameInput = document.getElementById('input-player-name');
                if (nameInput) {
                    nameInput.value = moodleName;
                    nameInput.readOnly = true;
                }
            }
        });

        function showView(viewId) {
            ['view-start', 'view-host', 'view-client'].forEach(id => document.getElementById(id).classList.add('hidden'));
            document.getElementById(viewId).classList.remove('hidden');
        }

        // --- NETZWERK ROBUSTHEIT ---
        function startHeartbeat() {
            // Sendet alle 20s ein Signal, damit Firewall Port offen l√§sst
            if(heartbeatInterval) clearInterval(heartbeatInterval);
            heartbeatInterval = setInterval(() => {
                if(peer && peer.socket && peer.socket._socket && peer.socket._socket.readyState === 1) {
                    peer.socket.send({type: 'HEARTBEAT'}); 
                }
            }, 20000);
        }

        function setupPeerEvents(p, isHost) {
            p.on('disconnected', () => {
                console.warn("Verbindung zum Server verloren. Versuche Reconnect...");
                // Bei "disconnected" k√∂nnen wir oft einfach reconnecten
                // ohne dass die P2P Verbindungen abbrechen!
                p.reconnect();
            });

            p.on('close', () => {
                alert("Verbindung komplett beendet. Bitte neu laden.");
                connections = {};
            });

            p.on('error', (err) => {
                console.error(err);
                // Ignoriere harmlose Fehler, alarmiere nur bei kritischen
                if (err.type === 'peer-unavailable') {
                    alert("Konnte Host nicht finden. Falsche ID?");
                } else if (err.type === 'fatal') {
                    alert("Kritischer Fehler: " + err);
                }
            });
        }

        // ==========================================
        // HOST LOGIC
        // ==========================================
        
        function initHost() {
            showView('view-host');
            const randomId = Math.floor(1000 + Math.random() * 9000); 
            const fullId = 'quiz-' + randomId;

            peer = new Peer(fullId, PEER_CONFIG);
            setupPeerEvents(peer, true);

            peer.on('open', (id) => { 
                document.getElementById('game-id-display').innerText = randomId; 
                startHeartbeat();
            });

            peer.on('connection', (c) => {
                c.on('open', () => setupHostConnection(c));
            });

            // File Handler
            document.getElementById('file-input').addEventListener('change', function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        quizData = JSON.parse(event.target.result);
                        if(!quizData.questions) throw new Error("Keine Fragen gefunden");
                        document.getElementById('btn-start-game').disabled = false;
                        alert(`Quiz geladen: ${quizData.questions.length} Fragen.`);
                    } catch(e) { alert("JSON Fehler: " + e.message); }
                };
                reader.readAsText(file);
            });
        }

        function setupHostConnection(c) {
            c.on('data', (data) => handleHostData(c.peer, data));
            c.on('close', () => {
                // Spieler hat Verbindung verloren -> Optional: Aus Liste entfernen oder grau markieren
                // Hier lassen wir ihn drin, falls er wiederkommt (Reload)
            });
            connections[c.peer] = c;
        }

        function handleHostData(peerId, data) {
            if (data.type === 'JOIN') {
                let safeName = (data.name || "Gast").substring(0, 15).replace(/</g, "&lt;");
                players[peerId] = { name: safeName, score: 0 };
                updatePlayerList();
                connections[peerId].send({ type: 'JOIN_CONFIRM' });
            } 
            else if (data.type === 'ANSWER' && questionActive) {
                // Verhindere doppelte Antworten
                if(players[peerId].hasAnsweredThisRound) return;
                
                players[peerId].hasAnsweredThisRound = true;
                answersCount++;
                document.getElementById('answers-received').innerText = answersCount + " Antworten";

                const q = quizData.questions[currentQuestionIndex];
                const isCorrect = checkAnswer(q, data.answerId);
                
                let points = 0;
                if (isCorrect) {
                    const elapsed = (Date.now() - questionStartTime) / 1000;
                    const factor = Math.max(0.5, 1 - (elapsed / TIME_LIMIT_SEC / 2));
                    points = Math.round(MAX_POINTS * factor);
                }

                players[peerId].score += points;

                const option = q.options.find(o => o.id === data.answerId);
                const feedbackText = option ? option.feedback : "";
                
                connections[peerId].send({
                    type: 'RESULT',
                    correct: isCorrect,
                    pointsAdded: points,
                    totalScore: players[peerId].score,
                    feedback: feedbackText
                });
            }
        }

        function checkAnswer(question, answerId) {
            const option = question.options.find(o => o.id === answerId);
            return option ? option.correct : false;
        }

        function updatePlayerList() {
            const list = document.getElementById('player-list');
            list.innerHTML = '';
            let count = 0;
            for (let pid in players) {
                const li = document.createElement('li');
                li.innerText = players[pid].name + " (" + players[pid].score + ")";
                list.appendChild(li);
                count++;
            }
            document.getElementById('player-count').innerText = count;
        }

        function startGame() {
            if (!quizData) return;
            document.getElementById('host-lobby').classList.add('hidden');
            document.getElementById('host-game').classList.remove('hidden');
            currentQuestionIndex = -1;
            nextQuestion();
        }

        function nextQuestion() {
            currentQuestionIndex++;
            document.getElementById('host-leaderboard').classList.add('hidden');
            document.getElementById('host-game').classList.remove('hidden');

            if (currentQuestionIndex >= quizData.questions.length) {
                finishGame();
                return;
            }

            // Reset Round Flags
            for(let pid in players) { players[pid].hasAnsweredThisRound = false; }

            const q = quizData.questions[currentQuestionIndex];
            
            document.getElementById('q-counter').innerText = `Frage ${currentQuestionIndex + 1} von ${quizData.questions.length}`;
            answersCount = 0;
            document.getElementById('answers-received').innerText = "0 Antworten";
            document.getElementById('host-question-text').innerHTML = q.text;
            
            const container = document.getElementById('host-options-container');
            container.innerHTML = '';
            document.getElementById('btn-resolve').classList.remove('hidden');
            document.getElementById('btn-show-ranking').classList.add('hidden');

            const labels = ["A", "B", "C", "D"];
            q.options.forEach((o, index) => {
                const div = document.createElement('div');
                div.className = 'host-option';
                div.id = `host-opt-${o.id}`;
                div.innerHTML = `<span class="opt-label fg-${index % 4}">${labels[index]}</span> <span>${o.text}</span>`;
                container.appendChild(div);
            });

            if(window.MathJax) MathJax.typeset();

            questionStartTime = Date.now();
            questionActive = true;

            const clientOptions = q.options.map((o, idx) => ({ id: o.id, index: idx }));
            broadcast({ type: 'QUESTION', options: clientOptions });
        }

        function resolveQuestion() {
            questionActive = false;
            document.getElementById('btn-resolve').classList.add('hidden');
            document.getElementById('btn-show-ranking').classList.remove('hidden');

            const q = quizData.questions[currentQuestionIndex];
            q.options.forEach(o => {
                const el = document.getElementById(`host-opt-${o.id}`);
                if (el) {
                    if (o.correct) el.classList.add('correct-reveal');
                    else el.style.opacity = "0.5";
                }
            });
        }

        function showLeaderboard() {
            document.getElementById('host-game').classList.add('hidden');
            document.getElementById('host-leaderboard').classList.remove('hidden');

            const sorted = Object.values(players).sort((a, b) => b.score - a.score);
            const list = document.getElementById('leaderboard-list');
            list.innerHTML = '';

            sorted.slice(0, 5).forEach((p, i) => {
                const div = document.createElement('div');
                div.className = 'leaderboard-entry';
                div.innerHTML = `<span class="lb-rank">#${i+1}</span> <span>${p.name}</span> <span class="lb-score">${p.score}</span>`;
                list.appendChild(div);
            });
        }

        function finishGame() {
            broadcast({ type: 'GAME_OVER' });
            showLeaderboard();
            const btn = document.querySelector('#host-leaderboard button');
            btn.innerText = "Neustart ‚Ü∫";
            btn.onclick = () => location.reload();
            document.querySelector('#host-leaderboard h1').innerText = "üèÅ Endergebnis";
        }

        function broadcast(msg) {
            for (let pid in connections) { 
                // Pr√ºfen ob Connection offen ist
                if(connections[pid] && connections[pid].open) {
                    connections[pid].send(msg); 
                }
            }
        }

        // ==========================================
        // CLIENT LOGIC
        // ==========================================

        function initClient() { showView('view-client'); }

        function joinGame() {
            const rawId = document.getElementById('input-game-id').value.trim();
            const name = document.getElementById('input-player-name').value.trim();
            
            if(!rawId || !name) return alert("Bitte ID und Name eingeben!");
            const gameId = rawId.startsWith('quiz-') ? rawId : 'quiz-' + rawId;

            document.getElementById('client-status').innerText = "Verbinde...";
            
            peer = new Peer(null, PEER_CONFIG); 
            setupPeerEvents(peer, false);

            peer.on('open', () => {
                startHeartbeat();
                connectToHost(gameId, name);
            });
        }

        function connectToHost(gameId, name) {
            conn = peer.connect(gameId, { reliable: true });
            
            conn.on('open', () => {
                document.getElementById('client-status').innerText = "Angemeldet!";
                conn.send({ type: 'JOIN', name: name });
            });

            conn.on('data', handleClientData);
            
            conn.on('close', () => {
                // Automatischer Reconnect Versuch bei Abbruch
                console.log("Host-Verbindung weg. Warte kurz...");
                // Hier k√∂nnten wir Logik einbauen, um reconnect zu versuchen, 
                // aber meist ist Neuladen sauberer.
                alert("Verbindung zum Lehrer unterbrochen.");
            });
            
            setTimeout(() => {
                if(!conn.open) document.getElementById('client-status').innerText = "Host antwortet nicht. ID korrekt?";
            }, 8000);
        }

        function handleClientData(data) {
            if (data.type === 'JOIN_CONFIRM') {
                document.getElementById('client-login').classList.add('hidden');
                document.getElementById('client-waiting').classList.remove('hidden');
            }
            else if (data.type === 'QUESTION') {
                document.getElementById('client-waiting').classList.add('hidden');
                document.getElementById('client-feedback').classList.add('hidden');
                document.getElementById('client-controls').classList.remove('hidden');
                renderClientButtons(data.options);
            }
            else if (data.type === 'RESULT') {
                document.getElementById('client-controls').classList.add('hidden');
                document.getElementById('client-feedback').classList.remove('hidden');
                
                const card = document.getElementById('feedback-card');
                const title = document.getElementById('feedback-title');
                const points = document.getElementById('feedback-points');
                
                if (data.correct) {
                    card.className = "feedback-screen fb-correct";
                    title.innerText = "RICHTIG! ü•≥";
                    points.innerText = "+ " + data.pointsAdded;
                } else {
                    card.className = "feedback-screen fb-wrong";
                    title.innerText = "FALSCH üò¢";
                    points.innerText = "+ 0";
                }
                document.getElementById('feedback-text').innerHTML = data.feedback || "";
                document.getElementById('client-total-score').innerText = data.totalScore + " Punkte";
            }
            else if (data.type === 'GAME_OVER') {
                document.getElementById('client-waiting').classList.remove('hidden');
                document.getElementById('client-feedback').classList.add('hidden');
                document.getElementById('waiting-msg').innerHTML = "<b>Spiel vorbei!</b><br>Schau auf den Screen.";
                document.querySelector('#client-waiting h1').innerText = "üèÅ";
            }
        }

        function renderClientButtons(options) {
            const container = document.getElementById('client-options-container');
            container.innerHTML = '';
            const labels = ["A", "B", "C", "D"];
            
            options.forEach((opt) => {
                const btn = document.createElement('div');
                btn.className = `client-btn bg-${opt.index % 4}`;
                btn.innerHTML = `<span>${labels[opt.index]}</span>`;
                btn.onclick = () => {
                    conn.send({ type: 'ANSWER', answerId: opt.id });
                    document.getElementById('client-controls').classList.add('hidden');
                    document.getElementById('client-waiting').classList.remove('hidden');
                    document.getElementById('waiting-msg').innerText = "Antwort gesendet!";
                    document.querySelector('#client-waiting h1').innerText = "‚è≥";
                };
                container.appendChild(btn);
            });
        }
    </script>
